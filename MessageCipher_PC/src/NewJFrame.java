/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.util.*;
import java.security.Key;
import java.security.KeyFactory;
import java.security.KeyPairGenerator;
import java.security.Signature;
import java.security.*;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import javax.crypto.Cipher;
import javax.swing.JOptionPane;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;


/**
 *
 * @author hp
 */
public class NewJFrame extends javax.swing.JFrame {

    /**
     * Creates new form NewJFrame
     */
    public NewJFrame() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        btnGenRandAesPwd = new javax.swing.JButton();
        hintAesPwdFormat = new javax.swing.JLabel();
        txtAesPwd = new javax.swing.JPasswordField();
        hintPublicKey = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        txtPublicKey = new javax.swing.JTextArea();
        btnClearPublicKey = new javax.swing.JButton();
        hintPrivateKey = new javax.swing.JLabel();
        jScrollPane2 = new javax.swing.JScrollPane();
        txtPrivateKey = new javax.swing.JTextArea();
        btnClearPrivateKey = new javax.swing.JButton();
        hintSignature = new javax.swing.JLabel();
        btnClearOppPublicKey = new javax.swing.JButton();
        jScrollPane3 = new javax.swing.JScrollPane();
        txtOppPublicKey = new javax.swing.JTextArea();
        hintEncryptedTxt = new javax.swing.JLabel();
        btnClearEncryptedText = new javax.swing.JButton();
        jScrollPane4 = new javax.swing.JScrollPane();
        txtEncryptedTxt = new javax.swing.JTextArea();
        btnGenKeys = new javax.swing.JButton();
        btnResetRsa = new javax.swing.JButton();
        btnGenCipheredText = new javax.swing.JButton();
        btnDecryptCipheredText = new javax.swing.JButton();
        hintAesPlainText = new javax.swing.JLabel();
        jScrollPane5 = new javax.swing.JScrollPane();
        txtAesPlainText = new javax.swing.JTextArea();
        btnClearAesPlainText = new javax.swing.JButton();
        btnEncryptAesPlainText = new javax.swing.JButton();
        hintAesEncryptedText = new javax.swing.JLabel();
        btnClearAesEncryptedText = new javax.swing.JButton();
        btnDecryptAesEncryptedText = new javax.swing.JButton();
        jScrollPane6 = new javax.swing.JScrollPane();
        txtAesEncryptedText = new javax.swing.JTextArea();
        btnClearAesText = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Message Cipher V2.1");
        setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));
        setLocationByPlatform(true);
        setMinimumSize(new java.awt.Dimension(1154, 568));

        btnGenRandAesPwd.setText("随机通讯密码");
        btnGenRandAesPwd.setToolTipText("");
        btnGenRandAesPwd.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnGenRandAesPwdActionPerformed(evt);
            }
        });

        hintAesPwdFormat.setText("通讯密码(16/24/32字符长度):");

        hintPublicKey.setText("己方RSA公钥(可公开的)");

        txtPublicKey.setColumns(20);
        txtPublicKey.setLineWrap(true);
        txtPublicKey.setRows(5);
        jScrollPane1.setViewportView(txtPublicKey);

        btnClearPublicKey.setText("清空");
        btnClearPublicKey.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnClearPublicKeyActionPerformed(evt);
            }
        });

        hintPrivateKey.setText("己方RSA私钥(务必保证安全)");

        txtPrivateKey.setColumns(20);
        txtPrivateKey.setLineWrap(true);
        txtPrivateKey.setRows(5);
        jScrollPane2.setViewportView(txtPrivateKey);

        btnClearPrivateKey.setText("清空");
        btnClearPrivateKey.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnClearPrivateKeyActionPerformed(evt);
            }
        });

        hintSignature.setText("对方RSA公钥");

        btnClearOppPublicKey.setText("清空");
        btnClearOppPublicKey.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnClearOppPublicKeyActionPerformed(evt);
            }
        });

        txtOppPublicKey.setColumns(20);
        txtOppPublicKey.setLineWrap(true);
        txtOppPublicKey.setRows(5);
        jScrollPane3.setViewportView(txtOppPublicKey);

        hintEncryptedTxt.setText("通讯密码密文");

        btnClearEncryptedText.setText("清空");
        btnClearEncryptedText.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnClearEncryptedTextActionPerformed(evt);
            }
        });

        txtEncryptedTxt.setColumns(20);
        txtEncryptedTxt.setLineWrap(true);
        txtEncryptedTxt.setRows(5);
        jScrollPane4.setViewportView(txtEncryptedTxt);

        btnGenKeys.setText("生成RSA密钥对");
        btnGenKeys.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnGenKeysActionPerformed(evt);
            }
        });

        btnResetRsa.setText("重置");
        btnResetRsa.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnResetRsaActionPerformed(evt);
            }
        });

        btnGenCipheredText.setText("生成通讯密码密文");
        btnGenCipheredText.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnGenCipheredTextActionPerformed(evt);
            }
        });

        btnDecryptCipheredText.setText("解密通讯密码密文");
        btnDecryptCipheredText.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnDecryptCipheredTextActionPerformed(evt);
            }
        });

        hintAesPlainText.setText("通讯明文");

        txtAesPlainText.setColumns(20);
        txtAesPlainText.setLineWrap(true);
        txtAesPlainText.setRows(5);
        jScrollPane5.setViewportView(txtAesPlainText);

        btnClearAesPlainText.setText("清除明文");
        btnClearAesPlainText.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnClearAesPlainTextActionPerformed(evt);
            }
        });

        btnEncryptAesPlainText.setText("加密");
        btnEncryptAesPlainText.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnEncryptAesPlainTextActionPerformed(evt);
            }
        });

        hintAesEncryptedText.setText("通讯密文");

        btnClearAesEncryptedText.setText("清除密文");
        btnClearAesEncryptedText.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnClearAesEncryptedTextActionPerformed(evt);
            }
        });

        btnDecryptAesEncryptedText.setText("解密");
        btnDecryptAesEncryptedText.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnDecryptAesEncryptedTextActionPerformed(evt);
            }
        });

        txtAesEncryptedText.setColumns(20);
        txtAesEncryptedText.setLineWrap(true);
        txtAesEncryptedText.setRows(5);
        jScrollPane6.setViewportView(txtAesEncryptedText);

        btnClearAesText.setText("清空");
        btnClearAesText.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnClearAesTextActionPerformed(evt);
            }
        });

        jLabel1.setText("此版本和V2.01版本的通讯编码互通    Powered by: Chenxi · 晨曦");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                        .addGroup(layout.createSequentialGroup()
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                .addComponent(hintAesPwdFormat, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(hintPublicKey, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                .addComponent(txtAesPwd, javax.swing.GroupLayout.PREFERRED_SIZE, 243, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGroup(layout.createSequentialGroup()
                                    .addComponent(btnGenKeys)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addComponent(btnClearPublicKey))))
                        .addGroup(layout.createSequentialGroup()
                            .addComponent(hintSignature)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(btnClearOppPublicKey))
                        .addGroup(layout.createSequentialGroup()
                            .addComponent(hintPrivateKey)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(btnClearPrivateKey))
                        .addGroup(layout.createSequentialGroup()
                            .addComponent(hintEncryptedTxt)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(btnClearEncryptedText))
                        .addComponent(jScrollPane4)
                        .addComponent(jScrollPane1)
                        .addComponent(jScrollPane2)
                        .addComponent(jScrollPane3))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(btnResetRsa)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btnGenCipheredText)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btnDecryptCipheredText)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 256, Short.MAX_VALUE)
                        .addComponent(btnClearAesText))
                    .addComponent(jScrollPane6)
                    .addComponent(jScrollPane5)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(hintAesEncryptedText)
                        .addGap(18, 18, 18)
                        .addComponent(btnClearAesEncryptedText)
                        .addGap(18, 18, 18)
                        .addComponent(btnDecryptAesEncryptedText))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(hintAesPlainText)
                                .addGap(18, 18, 18)
                                .addComponent(btnClearAesPlainText))
                            .addComponent(btnGenRandAesPwd))
                        .addGap(18, 18, 18)
                        .addComponent(btnEncryptAesPlainText)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(hintAesPwdFormat)
                    .addComponent(txtAesPwd, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(btnGenRandAesPwd))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(hintPublicKey)
                    .addComponent(hintAesPlainText)
                    .addComponent(btnEncryptAesPlainText)
                    .addComponent(btnClearAesPlainText)
                    .addComponent(btnGenKeys)
                    .addComponent(btnClearPublicKey))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(hintPrivateKey)
                            .addComponent(btnClearPrivateKey))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(hintSignature)
                            .addComponent(btnClearOppPublicKey))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addComponent(jScrollPane5, javax.swing.GroupLayout.PREFERRED_SIZE, 411, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(hintEncryptedTxt)
                                .addGap(18, 18, 18)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                    .addComponent(jScrollPane6)
                                    .addComponent(jScrollPane4)))
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                .addComponent(btnClearAesEncryptedText)
                                .addComponent(hintAesEncryptedText)
                                .addComponent(btnClearEncryptedText))
                            .addComponent(btnDecryptAesEncryptedText))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(btnResetRsa)
                            .addComponent(btnGenCipheredText)
                            .addComponent(btnDecryptCipheredText)))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addGap(0, 0, Short.MAX_VALUE)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel1)
                            .addComponent(btnClearAesText))))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void btnGenRandAesPwdActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnGenRandAesPwdActionPerformed
        // 生成随机AES密码并填充到AES密码框
        int pwd_length = 32;
        boolean digits_only = false;
        txtAesPwd.setText(createRandom(digits_only, pwd_length));
        
        // 清空数字签名和密文框
        txtOppPublicKey.setText("");
        txtEncryptedTxt.setText("");
        
        // 弹窗提示AES密码
        JOptionPane.showConfirmDialog(null, (new String(txtAesPwd.getPassword())), "通讯密码", JOptionPane.OK_OPTION);
        // 获取密码框内容
        //String s = new String(txtAesPwd.getPassword());
        
        // 测试
        //txtPublicKey.setText(s); // RSA公钥宽显示明文aes密码
        //txtEncryptedTxt.setText(encodeBASE64(s.getBytes())); // 在密文框显示base64编码后的aes密码
        // 从密文框取得内容并解码
        //String str = new String(txtEncryptedTxt.getText());
        //String new_str = new String(decodeBASE64(str));
        //txtPrivateKey.setText(new_str);
    }//GEN-LAST:event_btnGenRandAesPwdActionPerformed
    
    private void btnGenKeysActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnGenKeysActionPerformed
        // 生成RSA密钥对
        Map<String, Object> keys = initKey();
        
        // 清空数字签名和密文框
        txtOppPublicKey.setText("");
        txtEncryptedTxt.setText("");
        
        // 文本框显示密钥信息
        txtPublicKey.setText(getPublicKey(keys));
        txtPrivateKey.setText(getPrivateKey(keys));
    }//GEN-LAST:event_btnGenKeysActionPerformed

    private void btnResetRsaActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnResetRsaActionPerformed
        // TODO add your handling code here:
        // 清空RSA模块所有内容
        txtAesPwd.setText("");
        txtPublicKey.setText("");
        txtPrivateKey.setText("");
        txtOppPublicKey.setText("");
        txtEncryptedTxt.setText("");
    }//GEN-LAST:event_btnResetRsaActionPerformed

    private void btnClearAesPlainTextActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnClearAesPlainTextActionPerformed
        // TODO add your handling code here:
        txtAesPlainText.setText("");
    }//GEN-LAST:event_btnClearAesPlainTextActionPerformed

    private void btnEncryptAesPlainTextActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnEncryptAesPlainTextActionPerformed
        // TODO add your handling code here:
        // 获得密码
        String aes_pwd = new String(txtAesPwd.getPassword());
        // 获得明文文本
        String plain_text = txtAesPlainText.getText();
        // 判断都不为空并且密码长度
        if(aes_pwd.length() != 16 && aes_pwd.length() != 24 && aes_pwd.length() != 32){
            JOptionPane.showMessageDialog(null, "密码应为16/24/32字符长度", "错误", JOptionPane.ERROR_MESSAGE);
        }else if(plain_text == null || "".equals(plain_text)){
            JOptionPane.showMessageDialog(null, "需要提供明文", "错误", JOptionPane.ERROR_MESSAGE);
        }else{
            String result = encrypt(aes_pwd, plain_text);
            if (result == null || "".equals(result)){
                JOptionPane.showMessageDialog(null, "AES加密数据时出错", "错误", JOptionPane.ERROR_MESSAGE);
            }else{
                // 写入aes密文框
                txtAesEncryptedText.setText(result);
                // 清空明文框
                txtAesPlainText.setText("");
            }
        }
    }//GEN-LAST:event_btnEncryptAesPlainTextActionPerformed

    private void btnClearAesEncryptedTextActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnClearAesEncryptedTextActionPerformed
        // TODO add your handling code here:
        txtAesEncryptedText.setText("");
    }//GEN-LAST:event_btnClearAesEncryptedTextActionPerformed

    private void btnDecryptAesEncryptedTextActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnDecryptAesEncryptedTextActionPerformed
        // TODO add your handling code here:
        // 获得密码
        String aes_pwd = new String(txtAesPwd.getPassword());
        // 获得密文文本
        String encrypted_text = txtAesEncryptedText.getText();
        // 判断都不为空并且密码长度
        if(aes_pwd.length() != 16 && aes_pwd.length() != 24 && aes_pwd.length() != 32){
            JOptionPane.showMessageDialog(null, "密码应为16/24/32字符长度", "错误", JOptionPane.ERROR_MESSAGE);
        }else if(encrypted_text == null || "".equals(encrypted_text)){
            JOptionPane.showMessageDialog(null, "需要提供密文", "错误", JOptionPane.ERROR_MESSAGE);
        }else{
            String result = decrypt(aes_pwd, encrypted_text);
            if (result == null || "".equals(result)){
                JOptionPane.showMessageDialog(null, "AES解密数据时出错", "错误", JOptionPane.ERROR_MESSAGE);
            }else{
                // 写入aes明文框
                txtAesPlainText.setText(result);
            }
        }
    }//GEN-LAST:event_btnDecryptAesEncryptedTextActionPerformed

    private void btnClearAesTextActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnClearAesTextActionPerformed
        // TODO add your handling code here:
        txtAesPlainText.setText("");
        txtAesEncryptedText.setText("");
    }//GEN-LAST:event_btnClearAesTextActionPerformed

    private void btnClearEncryptedTextActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnClearEncryptedTextActionPerformed
        // TODO add your handling code here:
        txtEncryptedTxt.setText("");
    }//GEN-LAST:event_btnClearEncryptedTextActionPerformed

    private void btnClearPublicKeyActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnClearPublicKeyActionPerformed
        // TODO add your handling code here:
        txtPublicKey.setText("");
    }//GEN-LAST:event_btnClearPublicKeyActionPerformed

    private void btnClearPrivateKeyActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnClearPrivateKeyActionPerformed
        // TODO add your handling code here:
        txtPrivateKey.setText("");
    }//GEN-LAST:event_btnClearPrivateKeyActionPerformed

    private void btnClearOppPublicKeyActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnClearOppPublicKeyActionPerformed
        // TODO add your handling code here:
        txtOppPublicKey.setText("");
    }//GEN-LAST:event_btnClearOppPublicKeyActionPerformed

    private void btnDecryptCipheredTextActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnDecryptCipheredTextActionPerformed
        // TODO add your handling code here:
        String urPubKey = new String(txtPublicKey.getText());
        String urPriKey = new String(txtPrivateKey.getText());
        String oppPubKey = new String(txtOppPublicKey.getText());
        String cipheredText = new String(txtEncryptedTxt.getText());
        
        if("".equals(urPubKey)){
            JOptionPane.showMessageDialog(null, "需要己方RSA公钥", "错误", JOptionPane.ERROR_MESSAGE);
            return;
        }
        
        if("".equals(urPriKey)){
            JOptionPane.showMessageDialog(null, "需要己方RSA私钥", "错误", JOptionPane.ERROR_MESSAGE);
            return;
        }
        
        if("".equals(oppPubKey)){
            JOptionPane.showMessageDialog(null, "需要对方RSA公钥", "错误", JOptionPane.ERROR_MESSAGE);
            return;
        }
        
        if("".equals(cipheredText)){
            JOptionPane.showMessageDialog(null, "需要通讯密码密文", "错误", JOptionPane.ERROR_MESSAGE);
            return;
        }
        
        String[] sectors = cipheredText.split("\\.");
        if (sectors.length != 4){
            JOptionPane.showMessageDialog(null, "密文数据格式错误", "错误", JOptionPane.ERROR_MESSAGE);
            return;
        }
        
        // 如果己方私钥能解开第一段RSA密文就可以得到AES密码，也就是对方发来的消息
        String aes_crypt_communication_pwd = decryptByPrivateKey(sectors[0], urPriKey);
        boolean ur_message = false;
        String communication_pwd = "";
        
        // 这里是己方私钥解不开第一段RSA密文，就解开第二段RSA密文得到AES密码，也就是己方向对方发送的消息
        if ("".equals(aes_crypt_communication_pwd)){
            aes_crypt_communication_pwd = decryptByPrivateKey(sectors[1], urPriKey);
            ur_message = true;
        }
        
        // 如果再解不开，收工回家，报错得了
        if ("".equals(aes_crypt_communication_pwd)){
            JOptionPane.showMessageDialog(null, "无法使用己方RSA私钥取得保护密钥", "错误", JOptionPane.ERROR_MESSAGE);
            return;
        }
        
        // 这里肯定是已经获得了AES密码
        // AES解密数据 + 检查签名，签名有问题弹框框

        // 对方发送的，对方公钥验证签名
        if(!ur_message){
            // 无对方公钥则不验证
            if("".equals(oppPubKey)){
                JOptionPane.showConfirmDialog(null, "缺少对方RSA公钥无法验证数据签名", "提示", JOptionPane.OK_OPTION);
            }else{
               if(!verify(aes_crypt_communication_pwd, oppPubKey, sectors[2])){
                   JOptionPane.showConfirmDialog(null, "验证签名失败，保护密钥可能被篡改或者由于对方RSA公钥不匹配", "敬告", JOptionPane.OK_OPTION);
               } 
            }
        }else{
            
        }
        
        //System.out.println(aes_crypt_communication_pwd);
        
        communication_pwd = decrypt(aes_crypt_communication_pwd, sectors[3]);
        txtAesPwd.setText("");
        txtAesPwd.setText(communication_pwd);
        JOptionPane.showConfirmDialog(null, "成功取得通讯密钥", "提示", JOptionPane.OK_OPTION);
    }//GEN-LAST:event_btnDecryptCipheredTextActionPerformed

    private void btnGenCipheredTextActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnGenCipheredTextActionPerformed
        // TODO add your handling code here:
        String urPubKey = new String(txtPublicKey.getText());
        String urPriKey = new String(txtPrivateKey.getText());
        String oppPubKey = new String(txtOppPublicKey.getText());
        String communication_pwd = new String(txtAesPwd.getPassword());
        
        
        String aes_pwd_crypt_communication_pwd = createRandom(false, 32);
        String sector1 = ""; // 对方公钥加密的用于加密通讯密钥的密钥
        String sector2 = ""; // 己方公钥加密的用于加密通讯密钥的密钥
        String sector3 = ""; // 己方私钥对通讯密钥明文的签名
        String sector4 = ""; // 用密钥加密的通讯密钥
        String final_crypt_text = ""; // 最终密文
        
        if("".equals(urPubKey)){
            JOptionPane.showMessageDialog(null, "需要己方RSA公钥", "错误", JOptionPane.ERROR_MESSAGE);
            return;
        }
        
        if("".equals(urPriKey)){
            JOptionPane.showMessageDialog(null, "需要己方RSA私钥", "错误", JOptionPane.ERROR_MESSAGE);
            return;
        }
        
        if("".equals(oppPubKey)){
            JOptionPane.showMessageDialog(null, "需要对方RSA公钥", "错误", JOptionPane.ERROR_MESSAGE);
            return;
        }
        
        if("".equals(communication_pwd)){
            JOptionPane.showMessageDialog(null, "通讯密钥不能为空", "错误", JOptionPane.ERROR_MESSAGE);
            return;
        }
        
        if(communication_pwd.length() != 16 && communication_pwd.length() != 24 && communication_pwd.length() != 32){
            JOptionPane.showMessageDialog(null, "密码应为16/24/32字符长度", "错误", JOptionPane.ERROR_MESSAGE);
            return;
        }
        
        sector1 = encryptByPublicKey(aes_pwd_crypt_communication_pwd, oppPubKey);
        if("".equals(sector1)){
            JOptionPane.showMessageDialog(null, "用对方RSA公钥加密保护密钥时出错", "错误", JOptionPane.ERROR_MESSAGE);
            return;
        }
        
        sector2 = encryptByPublicKey(aes_pwd_crypt_communication_pwd, urPubKey);
        if("".equals(sector2)){
            JOptionPane.showMessageDialog(null, "用己方RSA公钥加密保护密钥时出错", "错误", JOptionPane.ERROR_MESSAGE);
            return;
        }
        
        sector3 = sign(aes_pwd_crypt_communication_pwd, urPriKey);
        if("".equals(sector3)){
            JOptionPane.showMessageDialog(null, "用己方RSA私钥对保护密钥签名时出错", "错误", JOptionPane.ERROR_MESSAGE);
            return;
        }
        
        sector4 = encrypt(aes_pwd_crypt_communication_pwd, communication_pwd);
        if("".equals(sector4) || sector4 == null){
            JOptionPane.showMessageDialog(null, "用保护密钥加密通讯密钥时出错", "错误", JOptionPane.ERROR_MESSAGE);
            return;
        }
        
        final_crypt_text = sector1 + "." + sector2 + "." + sector3 + "." + sector4;
        txtEncryptedTxt.setText("");
        txtEncryptedTxt.setText(final_crypt_text);
    }//GEN-LAST:event_btnGenCipheredTextActionPerformed

    
    /*
    RSA 部分
    */
    
    public static final String KEY_ALGORITHM = "RSA";
    //android系统的RSA实现是"RSA/None/NoPadding"，而标准JDK实现是"RSA/None/PKCS1Padding"
    public static final String ECB_PKCS1_PADDING = "RSA/ECB/PKCS1Padding";//加密填充方式 "RSA/ECB/PKCS1Padding"
    public static final String SIGNATURE_ALGORITHM = "MD5withRSA";
 
    private static final String PUBLIC_KEY = "RSAPublicKey";
    private static final String PRIVATE_KEY = "RSAPrivateKey";
    
    /**
     * 初始化密钥
     *
     * @return
     */
    public static Map<String, Object> initKey(){
        try {
            // RSA算法要求有一个可信任的随机数源
            SecureRandom secureRandom = new SecureRandom();
            
            KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance(KEY_ALGORITHM);
            //keyPairGen.initialize(2048);
            keyPairGen.initialize(2048, secureRandom);
            KeyPair keyPair = keyPairGen.generateKeyPair();
            // 公钥
            RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();
            // 私钥
            RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();

            //System.out.println(encodeBASE64(publicKey.getEncoded()));
            //System.out.println(encodeBASE64(privateKey.getEncoded()));
            
            Map<String, Object> keyMap = new HashMap<String, Object>(2);
            keyMap.put(PUBLIC_KEY, publicKey);
            keyMap.put(PRIVATE_KEY, privateKey);
            //System.out.println("密钥生成完毕");
            return keyMap;
            
        }catch(Exception e){
            //System.out.println("密钥生成失败");
            return null;
        }
    }
    
    
    /**
     * 取得私钥
     *
     * @param keyMap
     * @return
     */
    public static String getPrivateKey(Map<String, Object> keyMap){
        try{
            Key key = (Key) keyMap.get(PRIVATE_KEY);
            //(new BASE64Encoder()).encodeBuffer(keyBytes);(new BASE64Decoder()).decodeBuffer(data); ?? Base64.getEncoder().encodeToString(key);
            return byteToHex(key.getEncoded()); //v1
            //return Base64.getEncoder().encodeToString(key.getEncoded()); // v2
        }catch(Exception e){
            return "";
        }
    }
    
    /**
     * 取得公钥
     *
     * @param keyMap
     * @return
     */
    public static String getPublicKey(Map<String, Object> keyMap){
        try{
            Key key = (Key) keyMap.get(PUBLIC_KEY);
            return byteToHex(key.getEncoded()); //v1
            //return Base64.getEncoder().encodeToString(key.getEncoded()); // v2
        }catch(Exception e){
            return "";
        }
    }
    
    /**
     * 加密<br>
     * 用私钥加密
     *
     * @param data
     * @param key
     * @return
     */
    public static String encryptByPrivateKey(String data, String key){
        try{
            // 对密钥解密
            byte[] keyBytes = hexToByte(key);
            //byte[] keyBytes = (new BASE64Decoder()).decodeBuffer(key); // 正确方式
            
            // 取得私钥
            PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes);
            KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);
            Key privateKey = keyFactory.generatePrivate(pkcs8KeySpec);
            
            // 对数据加密
            //Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm());
            Cipher cipher = Cipher.getInstance(ECB_PKCS1_PADDING);
            cipher.init(Cipher.ENCRYPT_MODE, privateKey);
            
            //byte[] bytes = cipher.doFinal(data.getBytes());
            byte[] bytes = cipher.doFinal(data.getBytes("utf-8"));
            //byte[] bytes = cipher.doFinal((new BASE64Decoder()).decodeBuffer(data)); // 正确方式
            
            String result = byteToHex(bytes);
            
            //System.out.println("私钥加密数据正常");
            
            return result;
        }catch(Exception e){
            //System.out.println("私钥加密数据异常");
            e.printStackTrace(); 
            return "";
        }
    }
    
    /**
     * 解密<br>
     * 用私钥解密
     *
     * @param data
     * @param key
     * @return
     */
    public static String decryptByPrivateKey(String data, String key){
        try {
            // 对密钥解密
            byte[] keyBytes = hexToByte(key);
            //byte[] keyBytes = (new BASE64Decoder()).decodeBuffer(key); // 正确方式
 
            // 取得私钥
            PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes);
            KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);
            Key privateKey = keyFactory.generatePrivate(pkcs8KeySpec);
 
            // 对数据解密
            //Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm());
            Cipher cipher = Cipher.getInstance(ECB_PKCS1_PADDING);
            cipher.init(Cipher.DECRYPT_MODE, privateKey);
 
            byte[] original = cipher.doFinal(hexToByte(data));
            //byte[] original = cipher.doFinal((new BASE64Decoder()).decodeBuffer(data)); // 正确方式
            String result = new String(original,"utf-8");
            
            //System.out.println("私钥解密数据正常");
            
            return result;
        }catch(Exception e){
            //System.out.println("私钥解密数据异常");
            e.printStackTrace(); 
            return "";
        }
    }

    /**
     * 加密<br>
     * 用公钥加密
     *
     * @param data
     * @param key
     * @return
     */
    public static String encryptByPublicKey(String data, String key){
        try{
            // 对公钥解密
            byte[] keyBytes = hexToByte(key);
            //byte[] keyBytes = (new BASE64Decoder()).decodeBuffer(key); // 正确方式
            
            // 取得公钥
            X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(keyBytes);
            KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);
            Key publicKey = keyFactory.generatePublic(x509KeySpec);
            // 对数据加密
            //Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm());
            Cipher cipher = Cipher.getInstance(ECB_PKCS1_PADDING);
            cipher.init(Cipher.ENCRYPT_MODE, publicKey);
            
            //byte[] bytes = cipher.doFinal(data.getBytes());
            byte[] bytes = cipher.doFinal(data.getBytes("utf-8"));
            //byte[] original = cipher.doFinal((new BASE64Decoder()).decodeBuffer(data)); // 正确方式
            
            String result = byteToHex(bytes);
            
            //System.out.println("公钥加密数据正常");
            
            return result;
        }catch(Exception e){
            //System.out.println("公钥加密数据异常");
            e.printStackTrace(); 
            return "";
        }
    }
    
    /**
     * 解密<br>
     * 用公钥解密
     *
     * @param data
     * @param key
     */
    public static String decryptByPublicKey(String data, String key){
        try{
            // 对密钥解码
            byte[] keyBytes = hexToByte(key);
            //byte[] keyBytes = (new BASE64Decoder()).decodeBuffer(key); // 正确方式
            
            // 取得公钥
            X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(keyBytes);
            KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);
            Key publicKey = keyFactory.generatePublic(x509KeySpec);
                
            // 解密数据
            //Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm());
            Cipher cipher = Cipher.getInstance(ECB_PKCS1_PADDING);
            cipher.init(Cipher.DECRYPT_MODE, publicKey);
            
            byte[] bytes = cipher.doFinal(hexToByte(data));
            //byte[] bytes = cipher.doFinal((new BASE64Decoder()).decodeBuffer(data)); // 正确方式
            
            String result = new String(bytes, "utf-8");
            
            //System.out.println("公钥解密数据正常");
            
            // 返回解密后的数据
            return result;
        }catch(Exception e){
            //System.out.println("公钥解密数据异常");
            e.printStackTrace(); 
            return "";
        }
    }
    
    /**
     * 用私钥对信息生成数字签名
     *
     * @param data       加密数据
     * @param privateKey 私钥
     * @return
     */
    public static String sign(String data, String privateKey){
        try{
            // 解密由base64编码的私钥
            byte[] keyBytes = hexToByte(privateKey);
            //byte[] keyBytes = (new BASE64Decoder()).decodeBuffer(key); // 正确方式
            
            // 构造PKCS8EncodedKeySpec对象
            PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes);
 
            // KEY_ALGORITHM 指定的加密算法
            KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);
 
            // 取私钥匙对象
            PrivateKey priKey = keyFactory.generatePrivate(pkcs8KeySpec);
            
            // 用私钥对信息生成数字签名
            Signature signature = Signature.getInstance(SIGNATURE_ALGORITHM);
            signature.initSign(priKey);
            //signature.update(data.getBytes());
            signature.update(data.getBytes("utf-8"));
            
            //System.out.println("签名正常");
            
            return byteToHex(signature.sign()); // v1
            //return Base64.getEncoder().encodeToString(signature.sign()); //v2
        }catch(Exception e){
            //System.out.println("签名异常");
            e.printStackTrace(); 
            return "";
        }
    }
    
    /**
     * 校验数字签名
     *
     * @param data      加密数据
     * @param publicKey 公钥
     * @param sign      数字签名
     * @return 校验成功返回true 失败返回false
     */
    public static boolean verify(String data, String publicKey, String sign){
        try{
            // 解密由base64编码的公钥
            byte[] keyBytes = hexToByte(publicKey);
            //byte[] keyBytes = (new BASE64Decoder()).decodeBuffer(publicKey); // 正确方式
            
            // 构造X509EncodedKeySpec对象
            X509EncodedKeySpec keySpec = new X509EncodedKeySpec(keyBytes);
 
            // KEY_ALGORITHM 指定的加密算法
            KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);
 
            // 取公钥匙对象
            PublicKey pubKey = keyFactory.generatePublic(keySpec);
 
            Signature signature = Signature.getInstance(SIGNATURE_ALGORITHM);
            signature.initVerify(pubKey);
            signature.update(data.getBytes());
            //signature.update(data.getBytes("utf-8"));
            
            //System.out.println("验证签名正常");
            
            // 验证签名是否正常
            //byte[] original = cipher.doFinal((new BASE64Decoder()).decodeBuffer(data)); // 正确方式
            //(new BASE64Encoder()).encodeBuffer(keyBytes);(new BASE64Decoder()).decodeBuffer(data);
            
            return signature.verify(hexToByte(sign));
            //return signature.verify(Base64.getDecoder().decode(sign.getBytes("utf-8")));
            //return signature.verify((new BASE64Decoder()).decodeBuffer(sign)); // OK
        }catch(Exception e){
            //System.out.println("验证签名异常");
            e.printStackTrace(); 
            return false;
        }
    }
    
    /*
    输入：byte[]
    输出：String
    */
    public static String byteToHex(byte[] key) {
        // Base64编码
        try{
            //String str = Base64.getEncoder().encodeToString(key);
            //String str = (new BASE64Encoder()).encodeBuffer(key); // 与Android编码同步的正确方式
            //return str;
            String strHex = "";
            StringBuilder sb = new StringBuilder("");
            for (int n = 0; n < key.length; n++) {
                strHex = Integer.toHexString(key[n] & 0xFF);
                sb.append((strHex.length() == 1) ? "0" + strHex : strHex); // 每个字节由两个字符表示，位数不够，高位补0
            }
            return sb.toString().toUpperCase().trim();
        }catch(Exception e){
            return "Encode Error";
        }
    }

    /*
    输入：String
    输出：byte[]
    */
    public static byte[] hexToByte(String key) {
        // Base64解码
        try{
            //byte[] bt = Base64.getDecoder().decode(key);
            //byte[] bt = (new BASE64Decoder()).decodeBuffer(key); // 与Android编码同步的正确方式
            //return bt;
            int m = 0, n = 0;
            int byteLen = key.length() / 2; // 每两个字符描述一个字节
            byte[] ret = new byte[byteLen];
            for (int i = 0; i < byteLen; i++) {
                m = i * 2 + 1;
                n = m + 1;
                int intVal = Integer.decode("0x" + key.substring(i * 2, m) + key.substring(m, n));
                ret[i] = Byte.valueOf((byte)intVal);
            }
            return ret;
        }catch(Exception e){
            String err = "Decode Error";
            return err.getBytes();
        }
    }
    
    /*
    * 生成指定长度的随机字符串
    *
    * @param numberFlag:是否为纯数字
    * @param length:生成的字符串的长度
    * 
    * @return String
    */
    public static String createRandom(boolean numberFlag, int length){  
        String retStr = "";  
        String strTable = numberFlag ? "1234567890" : "`1234567890-=abcdefghijklmnopqrstuvwxyz~!@#$%^&*()_+[]{}ABCDEFGHIJKLMNOPQRSTUVWXYZ;:,./<>?\\\"";  
        int len = strTable.length();  
        boolean bDone = true;  
        do {  
            retStr = "";  
            int count = 0;  
            for (int i = 0; i < length; i++) {  
                double dblR = Math.random() * len;  
                int intR = (int) Math.floor(dblR);  
                char c = strTable.charAt(intR);  
                if (('0' <= c) && (c <= '9')) {  
                    count++;  
                }  
                retStr += strTable.charAt(intR);  
            }  
            if (count >= 2) {  
                bDone = false;  
            }  
        } while (bDone);  
        return retStr;  
    }  
    
    
    /*
    AES 部分
    */
    
    //private static final String CipherMode = "AES/ECB/PKCS5Padding";//使用ECB加密，不需要设置IV，但是不安全
    private static final String CipherMode = "AES/CFB/NoPadding";//使用CFB加密，需要设置IV

    /**
     * 对字符串加密
     *
     * @param key  密钥
     * @param data 源字符串
     * @return 加密后的字符串
     */
    public static String encrypt(String key, String data){
        try {
            Cipher cipher = Cipher.getInstance(CipherMode);
            SecretKeySpec keyspec = new SecretKeySpec(key.getBytes(), "AES");
            cipher.init(Cipher.ENCRYPT_MODE, keyspec, new IvParameterSpec(
                    new byte[cipher.getBlockSize()]));
            byte[] encrypted = cipher.doFinal(data.getBytes("utf-8"));
            //return Base64.encodeToString(encrypted, Base64.DEFAULT);
            //return Base64.getEncoder().encodeToString(encrypted); // OK
            return byteToHex(encrypted);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    /**
     * 对字符串解密
     *
     * @param key  密钥
     * @param data 已被加密的字符串
     * @return 解密得到的字符串
     */
    public static String decrypt(String key, String data){
        try {
            //byte[] encrypted1 = Base64.decode(data.getBytes());
            Cipher cipher = Cipher.getInstance(CipherMode);
            SecretKeySpec keyspec = new SecretKeySpec(key.getBytes(), "AES");
            cipher.init(Cipher.DECRYPT_MODE, keyspec, new IvParameterSpec(
                    new byte[cipher.getBlockSize()]));
            //byte[] original = cipher.doFinal(encrypted1);
            byte[] original = cipher.doFinal(hexToByte(data));
            //byte[] original = cipher.doFinal(Base64.getDecoder().decode(data));
            return new String(original,"utf-8");
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }
    
    
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new NewJFrame().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnClearAesEncryptedText;
    private javax.swing.JButton btnClearAesPlainText;
    private javax.swing.JButton btnClearAesText;
    private javax.swing.JButton btnClearEncryptedText;
    private javax.swing.JButton btnClearOppPublicKey;
    private javax.swing.JButton btnClearPrivateKey;
    private javax.swing.JButton btnClearPublicKey;
    private javax.swing.JButton btnDecryptAesEncryptedText;
    private javax.swing.JButton btnDecryptCipheredText;
    private javax.swing.JButton btnEncryptAesPlainText;
    private javax.swing.JButton btnGenCipheredText;
    private javax.swing.JButton btnGenKeys;
    private javax.swing.JButton btnGenRandAesPwd;
    private javax.swing.JButton btnResetRsa;
    private javax.swing.JLabel hintAesEncryptedText;
    private javax.swing.JLabel hintAesPlainText;
    private javax.swing.JLabel hintAesPwdFormat;
    private javax.swing.JLabel hintEncryptedTxt;
    private javax.swing.JLabel hintPrivateKey;
    private javax.swing.JLabel hintPublicKey;
    private javax.swing.JLabel hintSignature;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JScrollPane jScrollPane4;
    private javax.swing.JScrollPane jScrollPane5;
    private javax.swing.JScrollPane jScrollPane6;
    private javax.swing.JTextArea txtAesEncryptedText;
    private javax.swing.JTextArea txtAesPlainText;
    private javax.swing.JPasswordField txtAesPwd;
    private javax.swing.JTextArea txtEncryptedTxt;
    private javax.swing.JTextArea txtOppPublicKey;
    private javax.swing.JTextArea txtPrivateKey;
    private javax.swing.JTextArea txtPublicKey;
    // End of variables declaration//GEN-END:variables
}
